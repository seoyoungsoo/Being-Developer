해당 글에서 **프로토타입 기반의 프로그래밍이 무엇인지** 그리고 프로토타입 기반의 핵심을 지탱하는 `Prototype Object` 와 `Prototype Link` 에 대해 구분해보자

# 프로토타입 기반 프로그래밍

위키피디아 참조

> **프로토타입 기반 프로그래밍**은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있다. 
프로토타입 기반 프로그래밍은 **클래스리스**(class-less), **프로토타입 지향**(prototype-oriented) 혹은 **인스턴스 기반**(instance-based) 프로그래밍이라고도 한다.
> 

## 클래스 기반과의 비교

> 클래스기반 언어에서 객체는 일반적으로 두 가지 형태가 있다. '클래스'는 객체의 기본적인 만듦새와 기능을 정의하고, '인스턴스'는 "사용할 수 있는" 객체로 특정 클래스의 양식을 기반으로 한다. 클래스 기반 언어에서 '클래스'는 동작 방식인 메소드의 모임으로 동작하고, 모든 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있다. 한쪽에는 구조와 동작 방식, 다른 한쪽에는 상태로 구분된다.
많은 프로토타입 기반 체계가 실행시간에 프로토타입을 대체하기 쉬우나, 클래스기반 객체지향 체계에서는 최초의 동적 객체지향 체계인 스몰토크와 같이 프로그램의 실행 중에 클래스를 바꿀 수 있는 것은 몇 가지 되지 않는다.
프로토타입 기반 체계의 대부분은 인터프리터이고 동적 타입 프로그래밍 언어이다.
> 

자바스크립트에서는 객체의 원형인 프로토타입을 이용한 클로닝(Cloning: 복사)과 객체특성을 확장해 나가는 방식을 통해 새로운 객체를 생성해낸다.

자바스크립트의 프로토타입 객체의 확장은 **옵저버 패턴**을 따른다.

## 자바스크립트의 프로토타입이란?

### 설명 1

> 자바스크립트의 모든 객체는 자신을 생성한 객체 원형에 대한 숨겨진 연결을 갖는다. 이 때 자기 자신을 생성하기 위해 사용된 객체원형을 프로토타입이라 한다.
자바스크립트의 모든 객체는 Object 객체의 프로토타입을 기반으로 확장 되었기 때문에 이 연결의 끝은 Object 객체의 프로토타입 Objec다.
> 

### 설명2

> 프로토타입은 ECMAScript에서 구조, 상태, 습성을 구현하기 위해 사용하는 오브젝트이다.
생성자는 오브젝트를 생성할 때 그 오브젝트에 프로퍼티 레퍼런스를 가리킬 목적으로 생성자의 연관된 프로토타입을 참조하게 된다.
생성자와 연관된 프로토타입은 constructor.prototype과 같이 프로그램적인 표현으로 참조될 수 있고, native Object의 프로토타입에 추가되어진 프로퍼티가 공유되어진다.
> 

어떠한 객체가 만들어지기 위해 그 객체의 모태가 되는 녀석을 프로토타입(Prototype)이라고 한다.

### 예제 1

![Untitled](https://user-images.githubusercontent.com/58387974/135084744-0fcc8002-e1d7-40d7-9af4-b35f8607bb0c.png)

크롬에서 실행해본 간단한 예제로, 중요하게 봐야하는 부분은 `ProtoType` 과 `constructor` 다.

이 2개가 Eddy라는 객체를 만들어내기 위해 사용된 **객체원형에 대한 숨겨진 연결**이다.

자바스크립트의 모든 객체는 생성과 동시에 자기자신이 생성될 당시의 정보를 취한 `Prototype Object` 라는 새로운 객체를 Cloning하여 만들어낸다.

프로토 타입이 객체를 만들어내기 위한 원형이라면 이 `Prototype Object` 는 자기 자신의 분신이며 자신을 원형으로 만들어질 다른 객체가 참조할 프로토 타입이 된다.

즉 `ProtoType` 이라는 프로토타입에 대한 link는 상위에서 물려받은 객체의 프로토타입에 대한 정보이며, prototype 프로퍼티는 자신을 원형으로 만들어질 새로운 객체들, 하위에 물려줄 연결에 대한 속성이다.

![image2019-10-17_20-55-19](https://user-images.githubusercontent.com/58387974/135084752-2af3c4c2-8155-4ead-88ea-951df920c045.png)

위 관계도에서 알 수 있듯이 모든 객체의 확장은 **객체가 소유한 prototype Object를 통해 이루어지며 이 연결의 끝은 Object 객체의 prototype Object**가 된다.

일반적으로 자바스크립트 코드를 통해 다루는 prototype이 객체가 소유한 자기자신의 prototype Object 이기 때문에 대부분의 자바스크립트 입문자는 프로토타입이란 것을 prototype property라고 생각하게 되는 오류를 범하게 되는 것이다.

### 예제 2

```jsx
function info(x) {
	this.x = x;
}

const Eddy = new info('kind');
console.log(Eddy.x); // kind

cosole.log(Eddy.prototype.x); // syntax error
```

Eddy라는 객체는 info라는 원형을 이용하여 함수객체를 통해 만들어진 Object 단일 객체일 뿐이다.

즉, Eddy는 `prototype 프로퍼티` 를 소유하고 있지 않기 때문에 Eddy.prototype.x는 에러가 난다.

## Constructor (생성자)

> 생성자는 생성하고 초기화하는 함수 오브젝트이다. 각각의 생성자는 상속구현과 공유 프로퍼티 사용을 위해 연관된 프로토타입 오브젝트를 갖는다.
생성자를 포함하는 모든 함수들은 오브젝트지만 모든 오브젝트가 생성자가 되는 것은 아니다.
> 

![image2019-10-17_21-21-29](https://user-images.githubusercontent.com/58387974/135084757-eedbdba8-f60a-4101-a86d-ebe2084c8432.png)

첫 번째로 오브젝트가 직접 언급했던 프로퍼티의 유무를 조사한다. 만약 오브젝트가 정해진 프로퍼티를 포함한다면 그 레퍼런스가 참조하는 프로퍼티이다. 만약 그렇지 않다면 다음 프로토타입으로 넘어간다.

위의 예시를 예로 설명하자면 마지막에 childObject.name.toString();를 호출하는데, 최초 childObject가 가지고 있는 name을 참조한다. childObject는 name 프로퍼티를 가지고 있기 때문에 toString()을 수행하게 된다. 만약 name 프로퍼티가 존재하지 않는다면 fatherObject → grandObject → Object 순으로 찾아가게 된다.