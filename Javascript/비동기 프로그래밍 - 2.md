# 비동기 프로그래밍 (Asynchronous Programming)

어떤 일이 완료되기를 기다리지 않고 다음 코드를 실행해 나가는 프로그래밍 방식을 일러 **비동기 프로그래밍(asynchronous programming)**이라고 한다. 반대로 어떤 일이 완료될 때까지 코드의 실행을 멈추고 기다리는 프로그래밍 방식을 **동기식 프로그래밍(synchronous programming)**이라고 부른다.

브라우저에서 비동기 프로그래밍은 주로 **통신**과 같이 오래 걸리는 작업들을 브라우저에 위임할 때 이루어진다.

비동기 프로그래밍 방식은 대게 프로그램의 성능과 응답성을 높이는 데에 도움을 준다. 하지만 **코드가 실제로 실행되는 순서가 뒤죽박죽이 되므로**, 코드의 가독성을 해치고 디버깅을 어렵게 만든다는 비판을 받아왔다.

이런 문제를 해결하기 위해 비동기 프로그래밍을 위한 여러 기법이 생겨났다. 여기에서는 근래 Javascript 생태계에서 자주 사용되는 몇 가지 비동기 프로그래밍 기법들을 살펴보자

## 콜백 (Callback)

콜백은 다른 함수의 인수로 넘기는 함수를 말하는데, 이 콜백을 가지고 비동기 프로그래밍을 할 수 있다.

콜백에서는 주의할 것이 있다. 콜백을 인수로 받는 함수가 항상 비동기식으로 동작하는 것은 아니다!

콜백은 Javascript가 고차함수를 잘 지원한다는 특징 때문에 가장 많이 사용되는 비동기 프로그래밍 양식이었지만 콜백만으로 복잡한 비동기 데이터 흐름을 표현하기가 어려워서 많은 프로그래머들이 힘들어했고, 결국 **콜백 지옥(callback hell)**이라는 용어까지 생겼다.

## Promise

콜백의 문제를 해결하기 위해 여러 라이브러리들이 등장했고, 그 중 개발자들에게 널리 선택받은 것이 바로 Promise 패턴을 사용한 라이브러리들이다. 이 라이브러리들은 표준화되어, 결국 ES2015에 이르러 Javascript 언어 자체에 포함되게 되었다.

Promise는 **'언젠가 끝나는 작업'의 결과값**을 담는 통과 같은 객체이다. Promise 객체가 만들어지는 시점에는 그 통 안에 무엇이 들어갈지 모를 수도 있다. 대신 `then` 메소드를 통해 콜백을 등록해서, 작업이 끝났을 때 결과값을 가지고 추가 작업을 할 수 있다.

Promise 객체를 생성하는 가장 쉬운 방법은 `Promise.resolve` 정적 메소드를 사용하는 것이다.

```jsx
const p = Promise.resolve(1);
```

위 코드에서 `1` 이라는 결과값을 갖는 Promise 객체를 생성했다. 그러나 이 코드는 비동기 작업을 하고 있지는 않다.

비동기 작업을 하는 Promise 객체는 `Promise` 생성자를 통해 만들 수 있다.

```jsx
const p = new Promise((resolve, reject) => {
	setTimeout(() => {
		console.log('2초가 지났습니다.');
		resolve('hello');
	}, 2000);
});
```

`Promise` 생성자는 콜백을 인수로 받는다. 이 콜백의 첫 번째 인수로 `resolve` 함수가 들어오는데, 콜백 안에서 `resolve` 를 호출하면 `**resolve` 에 인수로 준 값이 곧 Promise 객체의 궁극적인 결과값이 된다.**

두 번째 인수로 들어오는 `reject` 함수는 비동기 작업에서 에러가 발생했을 때 호출하는 함수이다.

위 예제에서는 `setTimeout` 을 이용해 2초가 지난 뒤에 콜백이 실행되도록 했다. 즉, `p` 변수에 저장된 Promise 객체는 2초 동안은 결과값이 없는 상태가 된다. 그리고 2초가 지나면, `resolve` 함수가 호출되어 `p` 객체는 결과값을 갖는 객체가 된다.

Promise 객체의 **결과값을 사용해 추가 작업**을 하려면 `then` 메서드를 호출해야 한다. `then` 메서드에 콜백을 넘겨서, 첫 번째 인수로 들어온 결과값을 가지고 추가 작업을 할 수 있다.

```jsx
p.then(msg => {
	console.log(msg); // hello
});
```

`then` 메서드에는 아주 중요한 특징이 있는데, 바로 `**then` 메서드 자체도 Promise 객체를 반환**한다는 것이다. 이 때, 콜백에서 반환한 값이 곧 Promise의 결과값이 된다.

```jsx
const p2 = p.then(msg => {
	return msg + ' world';
});

p2.then(msg => {
	console.log(msg); // hello world
});
```

위 코드는 아래와 같이 줄여 쓸 수 있다.

```jsx
p.then(msg => {
	return msg + ' world';
}).then(msg => {
	console.log(msg);
});
```

또한, `then` 메서드에 넘겨준 콜백에서 Promise 객체를 반환하면, `then` 메서드가 반환한 Promise 객체는 앞의 Promise 객체의 결과를 따르게 된다.

Promise의 진가는, **복잡한 비동기 데이터 흐름을 다룰 때 발휘**된다.

별로 중요해보이지 않는 아래의 두 특징을 활용하면, 콜백만 사용했을 때보다 코드를 훨씬 더 깔끔하게 작성할 수 있다.

- `then` 메서드는 Promise 객체를 반환하므로, **콜백을 중첩하지 않고도 비동기 작업을 연이어 할 수 있다.**
- 비동기 작업이라는 동작 자체를 **값으로 다룰 수 있게 된다.** 즉, 이제까지 값을 다루면서 해왔던 모든 작업을 Promise 객체에 대해서도 할 수 있다.

## 비동기 함수 (Async Function)

Promise를 사용하는 비동기 프로그래밍 방식은 이전의 방식과 비교하면 여러 가지 장점을 갖지만, **여전히 콜백을 사용한다**는 점 때문에 '불편하다', '가독성이 좋지 않다'는 비판을 받아왔다.

ES2017에서 도입된 **비동기 함수(async function)**를 사용하면, 동기식 코드와 거의 같은 구조를 갖는 비동기식 코드를 짤 수 있다.

함수 앞에 `async` 키워드를 붙이면, 이 함수는 비동기 함수가 된다.

```jsx
// 비동기 함수
async function func1() {
	// ...
}

// 비동기 화살표 함수
const func = async () => {
	// ...
}

// 비동기 메서드
class MyClass {
	async myMethod() {
		// ...
	}
}
```

비동기 함수는 **항상 Promise 객체를 반환한다**는 특징을 갖는다. 이 Promise의 결과값은 비동기 함수 내에서 무엇을 반환하느냐에 따라 결정되며, `**then` 메서드와 똑같은 방식으로 동작한다.**

```jsx
async function func1() {
	return 1;
}

async function func2() {
	return Promise.resolve(2);
}

func1().then(console.log); // 1
func2().then(console.log); // 2
```

또 하나의 중요한 특징은 비동기 함수 내에서 `**await` 키워드**를 쓸 수 있다는 것이다. `await` 는 Promise의 `then` 메서드와 유사한 기능을 하는데, `**await` 키워드 뒤에 오는 Promise가 결과값을 가질 때까지 비동기 함수의 실행을 중단시킨다.** 여기서의 '중단'은 비동기식이며, 브라우저는 Promise가 완료될 때까지 다른 작업을 처리할 수 있다.

`await` 는 연산자이기도 하며, `**await` 연산의 결과값은 뒤에 오는 Promise 객체의 결과값**이 된다.

## Generator

generator 함수는 **'함수를 잠시 멈춰둘 수 있다'**는 특징을 갖고 있다. 이 특징으로 인해 generator가 비동기 프로그래밍을 위해 사용되기도 한다.

generator는 **함수의 재개를 프로그래머가 직접 제어할 수 있다**는 장점을 갖고 있기 때문에, 일부러 비동기 함수 대신 generator를 사용하는 경우도 있다. redux-saga 역시 generator를 활용하고 있다.